{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Pancaik Agents","text":"<p>Welcome to the Pancaik Agents documentation. This platform helps you create and manage autonomous agents that can perform scheduled tasks and provide interactive chat interfaces.</p>"},{"location":"#overview","title":"Overview","text":"<p>Pancaik Agents is a framework for building intelligent agents that can:</p> <ul> <li>Perform scheduled tasks to accomplish specific objectives</li> <li>Provide a chat interface for direct interaction</li> <li>Execute both one-off tasks and regular jobs</li> <li>Handle complex workflows autonomously</li> </ul>"},{"location":"#features","title":"Features","text":"<ul> <li>Task Automation: Agents accomplish objectives through scheduled one-off or recurring tasks</li> <li>Chat Interface: Direct interaction with agents through conversational interfaces</li> <li>Flexible Scheduling: Support for cron-style, interval-based, and one-time scheduling</li> <li>Extensible Architecture: Easy to customize and extend for specific use cases</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code># Install from PyPI\npip install pancaik\n\n# Or using Poetry\npoetry install\n</code></pre>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Building a Pancaik agent involves these simple steps:</p>"},{"location":"#1-define-your-agent-class-with-task-functions","title":"1. Define your agent class with task functions","text":"<pre><code># greeter_agent.py\nfrom pancaik.core.agent import Agent\n\nclass GreetingAgent(Agent):\n    \"\"\"An agent specialized in greetings and conversations\"\"\"\n\n    def __init__(self, id=None):\n        super().__init__(id=id)\n\n    async def greet(self, name=\"World\"):\n        \"\"\"Greet a person by name\"\"\"\n        greeting = f\"Hello, {name}! Nice to meet you.\"\n        return {\"greeting\": greeting}\n\n    async def greet_share_time(self, name=\"World\"):\n        \"\"\"Greet and share the current time\"\"\"\n        # Implementation here\n        pass\n\n    async def publish_tweet(self, tweet: str):\n        \"\"\"Post a tweet\"\"\"\n        # Implementation here\n        pass\n</code></pre>"},{"location":"#2-run-your-agent-directly","title":"2. Run your agent directly","text":"<pre><code># run_agent.py\nimport asyncio\nfrom greeter_agent import GreetingAgent\n\nasync def main():\n    # Create agent\n    greeter = GreetingAgent(id=\"demo_greeter\")\n\n    # Run various greeting tasks\n    await greeter.run(\"greet\", name=\"Alice\")\n    await greeter.run(\"greet_share_time\", name=\"Bob\")\n    await greeter.run(\"publish_tweet\", tweet=\"Having a great time with Pancaik! \ud83e\udd5e\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"#3-or-create-a-server-with-scheduled-tasks","title":"3. Or create a server with scheduled tasks","text":"<pre><code># run_server.py\nimport asyncio\nfrom contextlib import asynccontextmanager\nfrom datetime import datetime, timedelta\nfrom fastapi import FastAPI, APIRouter\nfrom greeter_agent import GreetingAgent\nfrom pancaik import init\nfrom pancaik.core import TaskHandler\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    # Initialize pancaik with configuration\n    await init({\n        \"db_connection\": \"mongodb://localhost:27017/pancaik\",\n        \"run_continuous\": True,\n        \"app_title\": \"Greeter Agent Demo\",\n        \"sleep_interval\": 5,\n        \"task_limit\": 10\n    })\n\n    # Initialize agent and schedule tasks\n    greeter = GreetingAgent()\n    now = datetime.now()\n\n    # Schedule multiple tasks with different delays\n    await greeter.schedule_task(\n        task_name=\"greet_and_tweet\", \n        next_run=now, \n        params={\"name\": \"Alice\"}\n    )\n    await greeter.schedule_task(\n        task_name=\"greet_share_time\", \n        next_run=now + timedelta(seconds=2), \n        params={\"name\": \"Bob\"}\n    )\n\n    yield\n\napp = FastAPI(lifespan=lifespan)\nrouter = APIRouter()\n\n@router.get(\"/greet/{name}\")\nasync def greet_person(name: str):\n    greeter = GreetingAgent()\n    task_id = await greeter.schedule_task(\n        task_name=\"greet_share_time\", \n        next_run=datetime.now(), \n        params={\"name\": name}\n    )\n    return {\"task_id\": task_id, \"message\": f\"Scheduled greeting for {name}\"}\n\napp.include_router(router)\n\nif __name__ == \"__main__\":\n    import uvicorn\n    uvicorn.run(\"run_server:app\", host=\"0.0.0.0\", port=8080, reload=True)\n</code></pre>"},{"location":"#use-cases","title":"Use Cases","text":"<ul> <li>Automated task scheduling and execution</li> <li>Interactive chatbots with custom business logic</li> <li>Workflow automation systems</li> <li>Data processing and monitoring agents</li> </ul>"},{"location":"#quick-navigation","title":"Quick Navigation","text":"<ul> <li>Features - Core capabilities of Pancaik Agents</li> <li>Tasks - How to set up and schedule agent tasks</li> <li>Examples - Sample use cases and implementations</li> </ul>"},{"location":"#license","title":"License","text":"<p>MIT License</p>"},{"location":"examples/","title":"Examples","text":"<p>Pancaik Agents provides a flexible framework for building various types of agents. This section showcases example agents for different use cases and demonstrates how Pancaik integrates with popular frameworks.</p>"},{"location":"examples/#use-case-examples","title":"Use Case Examples","text":"<p>Here are some examples of how Pancaik Agents can be used in various scenarios:</p>"},{"location":"examples/#social-media-management-agent","title":"Social Media Management Agent","text":"<p>This agent automatically generates and posts content to social media platforms.</p> <pre><code>agent:\n  name: social_media_bot\n  description: \"Posts daily content to Twitter and other platforms\"\n  tasks:\n    - name: daily_tweet\n      schedule: \"0 10 * * *\"  # Every day at 10 AM\n      handler: social.post_to_twitter\n      parameters:\n        content_generator: \"daily_thoughts\"\n        hashtags: [\"ai\", \"automation\"]\n\n    - name: weekly_summary\n      schedule: \"0 18 * * 5\"  # Every Friday at 6 PM\n      handler: social.weekly_engagement_summary\n      parameters:\n        platforms: [\"twitter\", \"linkedin\"]\n</code></pre>"},{"location":"examples/#customer-support-chatbot","title":"Customer Support Chatbot","text":"<p>A chat-based agent that can answer customer inquiries and create tickets for complex issues.</p> <pre><code>agent:\n  name: support_assistant\n  description: \"Customer support chatbot with knowledge base\"\n  chat:\n    enabled: true\n    greeting: \"Hello! I'm your support assistant. How can I help you today?\"\n    knowledge_base: \"support_docs\"\n    fallback_action: \"create_ticket\"\n  tasks:\n    - name: sync_knowledge\n      schedule: \"0 */3 * * *\"  # Every 3 hours\n      handler: support.update_knowledge_base\n</code></pre>"},{"location":"examples/#quotation-system","title":"Quotation System","text":"<p>An agent that can receive inquiries, process them, and generate quotations.</p> <pre><code>agent:\n  name: quotation_system\n  description: \"Processes quotation requests and generates quotes\"\n  chat:\n    enabled: true\n    forms:\n      - name: quote_request\n        fields:\n          - name: product_type\n            type: select\n            options: [\"Software\", \"Hardware\", \"Services\"]\n          - name: quantity\n            type: number\n          - name: delivery_date\n            type: date\n  tasks:\n    - name: process_quotes\n      schedule: \"*/30 * * * *\"  # Every 30 minutes\n      handler: quotes.process_pending\n    - name: send_followups\n      schedule: \"0 9 * * *\"  # Every day at 9 AM\n      handler: quotes.send_followup_emails\n</code></pre>"},{"location":"examples/#content-aggregator","title":"Content Aggregator","text":"<p>An agent that regularly aggregates content from different sources and creates a digest.</p> <pre><code>agent:\n  name: news_digest\n  description: \"Creates a daily digest of news from multiple sources\"\n  tasks:\n    - name: fetch_content\n      schedule: \"0 */4 * * *\"  # Every 4 hours\n      handler: content.fetch_from_sources\n      parameters:\n        sources: \n          - name: \"tech_blog\"\n            url: \"https://techblog.com/rss\"\n          - name: \"industry_news\"\n            url: \"https://industrynews.com/feed\"\n\n    - name: generate_digest\n      schedule: \"0 6 * * *\"  # Every day at 6 AM\n      handler: content.create_digest\n      parameters:\n        format: \"html\"\n        distribution: [\"email\", \"website\"]\n</code></pre>"},{"location":"examples/#framework-integrations","title":"Framework Integrations","text":"<p>Pancaik Agents provides seamless integration with popular AI orchestration frameworks, allowing you to leverage their capabilities while maintaining the simplicity and power of the Pancaik ecosystem.</p>"},{"location":"examples/#basic-agent","title":"Basic Agent","text":"<p>Our Basic Greeter Agent demonstrates the core functionality of Pancaik Agents, showing how to:</p> <ul> <li>Create a simple agent with multiple methods</li> <li>Configure task pipelines and schedules</li> <li>Return structured data between method calls</li> <li>Combine tasks into more complex workflows</li> </ul> <p>Read more about the Basic Agent example \u2192</p>"},{"location":"examples/#langgraph-integration","title":"LangGraph Integration","text":"<p>The LangGraph integration demonstrates how to create complex workflows with conditional logic and stateful execution:</p> <ul> <li>Define multi-step workflows with branching</li> <li>Maintain state across multiple processing steps</li> <li>Implement feedback loops for content refinement</li> <li>Create complex decision trees with LLM-based decisions</li> </ul> <p>Read more about the LangGraph integration \u2192</p>"},{"location":"examples/#crewai-integration","title":"CrewAI Integration","text":"<p>The CrewAI integration showcases how to create specialized agent teams with different roles:</p> <ul> <li>Create role-based agents with specific goals and backstories</li> <li>Design tasks with clear descriptions and expected outputs</li> <li>Enable agent collaboration and context sharing</li> <li>Orchestrate multi-agent workflows with sequential execution</li> </ul> <p>Read more about the CrewAI integration \u2192</p> <p>Each of these examples demonstrates how Pancaik Agents can be adapted to different use cases and integrated with different frameworks while maintaining a consistent, simple interface. All examples are available in the repository under the <code>examples</code> directory. </p>"},{"location":"features/","title":"Features","text":"<p>Pancaik Agents provides a powerful framework for creating intelligent agents with multiple capabilities:</p>"},{"location":"features/#core-features","title":"Core Features","text":""},{"location":"features/#task-automation","title":"Task Automation","text":"<p>Agents can be assigned regular tasks to accomplish specific objectives. These tasks can be: - One-off tasks for single execution - Recurring jobs with custom schedules - Complex workflows with multiple steps</p>"},{"location":"features/#interactive-chat-interface","title":"Interactive Chat Interface","text":"<p>Every agent comes with a built-in chat interface that allows for: - Direct interaction with users - Natural language understanding - Contextual responses based on the agent's knowledge base - Custom personality and response styles</p>"},{"location":"features/#scheduling-system","title":"Scheduling System","text":"<p>The platform includes a robust scheduling system that supports: - Cron-style scheduling - Time-based triggers - Event-based execution - Dependency management between tasks</p>"},{"location":"features/#extensibility","title":"Extensibility","text":"<p>Agents can be extended with: - Custom plugins - Integration with external APIs - Domain-specific knowledge bases - Special capabilities based on your needs</p>"},{"location":"features/#technical-capabilities","title":"Technical Capabilities","text":"<ul> <li>Python-based: Built with modern Python for excellent performance and readability</li> <li>FastAPI Backend: High-performance API layer with automatic documentation</li> <li>MongoDB Storage: Flexible document storage for agent data and state</li> <li>YAML Configuration: Simple and readable configuration files </li> </ul>"},{"location":"server/","title":"Server and Task Execution","text":"<p>The Pancaik Agents framework includes a built-in server that manages task execution and provides HTTP endpoints for interacting with your agents.</p>"},{"location":"server/#how-the-server-works","title":"How the Server Works","text":"<p>The server component of Pancaik Agents handles:</p> <ol> <li>Task scheduling and execution</li> <li>API endpoints for task management</li> <li>Custom endpoints for your application</li> </ol> <p>The server setup is simple and uses FastAPI's lifespan for proper initialization and cleanup:</p> <pre><code>from fastapi import FastAPI\nfrom contextlib import asynccontextmanager\nfrom pancaik import init\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    # Initialize pancaik with configuration\n    await init({\n        \"db_connection\": \"mongodb://localhost:27017/pancaik\",  # Optional DB connection\n        \"run_continuous\": True,  # Set to True for continuous task running\n        \"app_title\": \"Your Application Title\",\n        \"sleep_interval\": 5,  # Run tasks every 5 seconds\n        \"task_limit\": 10  # Process up to 10 tasks per run\n    })\n\n    yield\n\n    # Cleanup on shutdown\n    db = get_config(\"db\")\n    if db is not None:\n        db.client.close()\n\napp = FastAPI(lifespan=lifespan)\n\nif __name__ == \"__main__\":\n    import uvicorn\n    uvicorn.run(\"main:app\", host=\"0.0.0.0\", port=8080, reload=True)\n</code></pre>"},{"location":"server/#task-execution-flow","title":"Task Execution Flow","text":"<ol> <li>Tasks are scheduled with their next run time</li> <li>The server continuously checks for tasks that are due to run based on the configured <code>sleep_interval</code></li> <li>When a task's scheduled time arrives, the server executes the corresponding agent method</li> <li>The server processes up to <code>task_limit</code> tasks per run</li> </ol> <p>Example of scheduling tasks:</p> <pre><code># Initialize agent and schedule tasks\ngreeter = GreetingAgent()\nnow = datetime.now()\n\n# Schedule multiple tasks with different delays\nawait greeter.schedule_task(task_name=\"greet_and_tweet\", next_run=now, params={\"name\": \"Alice\"})\nawait greeter.schedule_task(\n    task_name=\"greet_share_time\", \n    next_run=now + timedelta(seconds=2), \n    params={\"name\": \"Bob\"}\n)\n</code></pre>"},{"location":"server/#adding-custom-endpoints","title":"Adding Custom Endpoints","text":"<p>You can extend the server with custom endpoints using FastAPI's router. Here's how to add endpoints:</p> <pre><code>from fastapi import FastAPI, APIRouter\n\n# Create a router for custom endpoints\nrouter = APIRouter()\n\n@router.get(\"/hello\")\nasync def hello_world():\n    return {\"message\": \"Hello, World!\"}\n\n@router.get(\"/greet/{name}\")\nasync def greet_person(name: str):\n    greeter = GreetingAgent()\n    task_id = await greeter.schedule_task(\n        task_name=\"greet_share_time\",\n        next_run=datetime.now(),\n        params={\"name\": name}\n    )\n    return {\"task_id\": task_id, \"message\": f\"Scheduled greeting for {name}\"}\n\n# Include the router in the app\napp.include_router(router)\n</code></pre> <p>After starting your server, you can access your endpoints: - <code>http://localhost:8080/hello</code> returns: <code>{\"message\": \"Hello, World!\"}</code> - <code>http://localhost:8080/greet/Alice</code> schedules a greeting task for Alice</p> <p>The server supports both synchronous and asynchronous endpoint handlers, and you can organize your routes using FastAPI's powerful routing system. </p>"},{"location":"tasks/","title":"Tasks","text":"<p>Tasks are central to the Pancaik Agents platform. They represent regular jobs that are scheduled to achieve specific objectives, which can be one-off tasks or recurring jobs.</p>"},{"location":"tasks/#task-types","title":"Task Types","text":""},{"location":"tasks/#one-off-tasks","title":"One-off Tasks","text":"<p>One-time tasks that execute once and then complete. These are useful for: - Data migration jobs - Setup procedures - Cleanup operations - One-time data processing</p>"},{"location":"tasks/#recurring-tasks","title":"Recurring Tasks","text":"<p>Jobs that run on a schedule, performing the same operation repeatedly. Examples include: - Daily social media posts - Hourly data synchronization - Weekly report generation - Monthly analytics processing</p>"},{"location":"tasks/#task-configuration","title":"Task Configuration","text":"<p>Tasks are configured using a simple declarative syntax in YAML:</p> <pre><code>tasks:\n  daily_twitter_post:\n    objective: \"Posts a daily thought to Twitter\"\n    scheduler:\n      type: \"cron\"\n      params:\n        expression: \"0 9 * * *\"  # Runs at 9 AM daily\n    pipeline:\n      - generate_content\n      - publish_to_twitter\n    params:\n      content_source: \"thoughts_database\"\n      hashtags: [\"dailythought\", \"pancaikagent\"]\n</code></pre>"},{"location":"tasks/#scheduler-system","title":"Scheduler System","text":"<p>The Pancaik Agents platform includes a robust scheduler that supports multiple scheduling types:</p>"},{"location":"tasks/#cron-style-scheduling","title":"Cron-style Scheduling","text":"<p>For recurring tasks based on precise time patterns:</p> <pre><code>scheduler:\n  type: \"cron\"\n  params:\n    expression: \"*/15 * * * *\"  # Every 15 minutes\n</code></pre>"},{"location":"tasks/#random-interval-scheduling","title":"Random Interval Scheduling","text":"<p>For tasks that should run at random times within specified ranges:</p> <pre><code>scheduler:\n  type: \"random_interval\"\n  params:\n    min_minutes: 5\n    max_minutes: 30  # Random time between 5-30 minutes\n</code></pre>"},{"location":"tasks/#one-time-scheduling","title":"One-time Scheduling","text":"<p>For tasks that should run exactly once at a specific time:</p> <pre><code>scheduler:\n  type: \"one_time\"\n  params:\n    scheduled_time: \"2023-10-15T14:30:00\"  # Specific date and time\n</code></pre>"},{"location":"tasks/#retry-policy","title":"Retry Policy","text":"<p>When a task fails, the system can automatically retry it based on a configurable retry policy. This allows you to specify how and when to retry failed tasks.</p>"},{"location":"tasks/#default-behavior","title":"Default Behavior","text":"<p>By default, failed tasks will be retried after 10 minutes.</p>"},{"location":"tasks/#configuring-retry-policies","title":"Configuring Retry Policies","text":"<p>You can configure retry policies in your task definitions:</p> <pre><code>tasks:\n  data_sync:\n    objective: \"Synchronize data from external API\"\n    scheduler:\n      type: \"cron\"\n      params:\n        expression: \"0 */2 * * *\"  # Every 2 hours\n    retry_policy:\n      minutes: 30  # Retry after 30 minutes on failure\n    pipeline:\n      - fetch_data\n      - process_data\n      - save_to_database\n</code></pre>"},{"location":"tasks/#disabling-retries","title":"Disabling Retries","text":"<p>To disable retries for a specific task, set the retry_policy to <code>false</code>:</p> <pre><code>tasks:\n  critical_process:\n    objective: \"Run critical process that should not be retried\"\n    scheduler:\n      type: \"cron\"\n      params:\n        expression: \"0 0 * * *\"  # Daily at midnight\n    retry_policy: false  # No retries on failure\n    pipeline:\n      - run_critical_process\n</code></pre>"},{"location":"tasks/#task-pipeline","title":"Task Pipeline","text":"<p>Each task defines a pipeline of steps to execute in sequence:</p> <pre><code>pipeline:\n  - step_one\n  - step_two\n  - step_three\n</code></pre> <p>Each step in the pipeline corresponds to: - A method in the agent class - A registered tool - Another task</p>"},{"location":"tasks/#task-lifecycle","title":"Task Lifecycle","text":"<ol> <li>Definition: Tasks are defined in the agent's configuration YAML</li> <li>Initialization: </li> <li>The agent's <code>init_tasks()</code> method checks for existing tasks in the database</li> <li>It only schedules tasks from the config that aren't already scheduled</li> <li>Returns a dictionary mapping task names to their IDs</li> <li>Scheduling: </li> <li>The <code>schedule_task()</code> method handles task scheduling</li> <li>If no execution time is provided, it calculates the next run time based on scheduler configuration:<ul> <li>For <code>random_interval</code>: Selects a random time between min_minutes and max_minutes</li> <li>For <code>cron</code>: Uses croniter to calculate the next run based on the cron expression</li> <li>For <code>one_time</code>: Uses the provided scheduled_time</li> </ul> </li> <li>It registers the task with the TaskHandler system</li> <li>Execution: When the task's time arrives, the system invokes the agent with the task</li> <li>Pipeline Processing: </li> <li>The agent executes each step in the task's pipeline using the <code>run()</code> method</li> <li>Results from each step are stored in the agent's data_store</li> <li>Completion: Results are recorded and any follow-up actions are triggered</li> <li>Task Management:</li> <li>Tasks can be manually scheduled using <code>schedule_task()</code></li> <li>Existing tasks can be cleared using <code>clear_tasks()</code></li> </ol>"},{"location":"tasks/#practical-examples","title":"Practical Examples","text":""},{"location":"tasks/#creating-and-initializing-an-agent-with-tasks","title":"Creating and Initializing an Agent with Tasks","text":"<pre><code>import asyncio\nfrom pancaik.core.agent import Agent\n\n# Create agent from YAML config file\nasync def setup_twitter_agent():\n    # Create agent instance - will automatically load the YAML config\n    twitter_agent = Agent(yaml_path=\"agents/TwitterAgent.yaml\", id=\"twitter_bot_1\")\n\n    # Initialize all tasks from the config\n    task_ids = await twitter_agent.init_tasks()\n    print(f\"Initialized tasks: {task_ids}\")\n\n    return twitter_agent\n\n# Manual task scheduling\nasync def schedule_custom_tweet(agent: Agent, tweet_content: str):\n    # Schedule a one-time task to post specific content\n    task_id = await agent.schedule_task(\n        task_name=\"post_single_tweet\",\n        next_run=None,  # Will use the scheduler config from YAML\n        params={\n            \"content\": tweet_content,\n            \"hashtags\": [\"custom\", \"pancaikagent\"]\n        }\n    )\n    print(f\"Scheduled custom tweet with task_id: {task_id}\")\n\n# Usage\nasync def main():\n    agent = await setup_twitter_agent()\n\n    # Schedule a custom task\n    await schedule_custom_tweet(\n        agent, \n        \"Check out our new Pancaik Agents platform!\"\n    )\n\n    # Clear specific tasks if needed\n    cleared_count = await agent.clear_tasks([\"daily_twitter_post\"])\n    print(f\"Cleared {cleared_count} tasks\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"tasks/#example-task-execution-flow","title":"Example Task Execution Flow","text":"<p>When a task is executed, the system performs these operations:</p> <pre><code># Pseudocode of the internal execution flow\nasync def execute_task(agent_id, task_name, params):\n    # 1. Load the agent\n    agent = Agent.from_config({\"id\": agent_id, \"class\": \"path.to.AgentClass\"})\n\n    # 2. Run the task - this executes the pipeline steps in sequence\n    results = await agent.run(task_name, **params)\n\n    # 3. For recurring tasks, reschedule the next run\n    task_config = agent.tasks[task_name]\n    if is_recurring_task(task_config):\n        await agent.schedule_task(task_name)\n\n    return results\n</code></pre>"},{"location":"agents/","title":"Agents Overview","text":"<p>Pancaik provides a flexible agent-based architecture that allows you to create, configure, and run automated agents for various tasks.</p>"},{"location":"agents/#available-agents","title":"Available Agents","text":"<ul> <li>TwitterAgent: For interacting with Twitter, monitoring accounts, and indexing tweets.</li> </ul>"},{"location":"agents/#common-agent-configuration","title":"Common Agent Configuration","text":"<p>Agents in Pancaik are configured using YAML files that define:</p> <ol> <li>Agent identity and metadata</li> <li>Service-specific credentials and settings</li> <li>Tasks the agent should perform</li> <li>Scheduling details for those tasks</li> </ol> <p>Each agent type has its own specific configuration options, which are documented in their respective pages. </p>"},{"location":"agents/twitter_agent/","title":"TwitterAgent","text":"<p>The TwitterAgent allows you to monitor Twitter accounts, index tweets, and interact with the Twitter platform programmatically.</p>"},{"location":"agents/twitter_agent/#tasks","title":"Tasks","text":""},{"location":"agents/twitter_agent/#index_followed_users","title":"index_followed_users","text":"<p>This task indexes tweets from the users specified in the <code>followed_users</code> configuration.</p> <pre><code>tasks:\n  index_followed_users:\n    scheduler:\n      type: \"cron\"\n      params:\n        expression: \"*/5 * * * *\"  # Runs every 5 minutes\n    pipeline:\n      - index_tweets\n</code></pre>"},{"location":"agents/twitter_agent/#index_own_mentions","title":"index_own_mentions","text":"<p>This task indexes mentions of the agent's Twitter account, allowing you to monitor and respond to tweets that mention your account.</p> <pre><code>tasks:\n  index_own_mentions:\n    scheduler:\n      type: \"cron\"\n      params:\n        expression: \"*/5 * * * *\"  # Runs every 5 minutes\n    pipeline:\n      - index_mentions\n</code></pre>"},{"location":"agents/twitter_agent/#reply_own_mentions","title":"reply_own_mentions","text":"<p>This task automatically replies to mentions of the agent's Twitter account.</p> <pre><code>tasks:\n  reply_own_mentions:\n    scheduler:\n      type: \"cron\"\n      params:\n        expression: \"*/5 * * * *\"  # Runs every 5 minutes\n    pipeline:\n      - select_mention_to_reply\n      - compose_tweet_from_context\n      - publish_tweet\n      - mark_mention_as_reviewed\n      - index_tweet_by_id\n</code></pre>"},{"location":"agents/twitter_agent/#post_from_followed_users","title":"post_from_followed_users","text":"<p>This task creates posts based on content from followed users.</p> <pre><code>tasks:\n  post_from_followed_users:\n    scheduler:\n      type: \"random_interval\"\n      params:\n        min_minutes: 120\n        max_minutes: 360\n    pipeline:\n      - select_topics_from_followed_users\n      - compose_tweet_from_context\n      - publish_tweet\n      - index_tweet_by_id\n</code></pre>"},{"location":"agents/twitter_agent/#post_from_daily_research","title":"post_from_daily_research","text":"<p>This task generates and posts content based on daily research of followed topics.</p> <pre><code>tasks:\n  post_from_daily_research:\n    scheduler:\n      type: \"random_interval\"\n      params:\n        min_minutes: 120\n        max_minutes: 360\n    pipeline:\n      - get_daily_content_from_followed_users\n      - generate_daily_research\n      - generate_daily_topics_from_research\n      - select_topics_from_daily_research\n      - research_topic\n      - compose_tweet_from_context\n      - publish_tweet\n      - index_tweet_by_id\n      - mark_topic_as_posted\n</code></pre>"},{"location":"agents/twitter_agent/#comment_on_followed_users","title":"comment_on_followed_users","text":"<p>This task automatically comments on posts from followed users.</p> <pre><code>tasks:\n  comment_on_followed_users:\n    scheduler:\n      type: \"random_interval\"\n      params:\n        min_minutes: 30\n        max_minutes: 60\n    pipeline:\n      - select_post_from_followed_user_to_comment\n      - compose_tweet_from_context\n      - publish_tweet\n      - index_tweet_by_id\n      - mark_post_as_commented\n</code></pre>"},{"location":"agents/twitter_agent/#reply_to_search_results","title":"reply_to_search_results","text":"<p>This task searches for relevant tweets and replies to them based on daily research.</p> <pre><code>tasks:\n  reply_to_search_results:\n    scheduler:\n      type: \"random_interval\"\n      params:\n        min_minutes: 15\n        max_minutes: 30\n    pipeline:\n      - get_daily_content_from_followed_users\n      - generate_daily_research\n      - generate_daily_search_queries_from_research\n      - search_posts_to_reply\n      - compose_tweet_from_context\n      - publish_tweet\n      - index_tweet_by_id\n</code></pre> <p>The scheduler can be configured with different types:</p> <ul> <li><code>cron</code>: Uses cron expressions for scheduling</li> <li><code>interval</code>: Runs at fixed intervals (in seconds)</li> <li><code>once</code>: Runs once at startup</li> <li><code>random_interval</code>: Runs at random intervals between specified minutes</li> </ul>"},{"location":"agents/twitter_agent/#configuration","title":"Configuration","text":"<p>TwitterAgent is configured using a YAML file. You can place this in your project directory or specify a path when initializing the agent.</p>"},{"location":"agents/twitter_agent/#basic-configuration-structure","title":"Basic Configuration Structure","text":"<pre><code>name: \"Twitter Agent\"\ntwitter:\n  credentials:\n    username: \"\"\n    user_id: \"\"\n    password: \"\"\n    email: \"\"\n    consumer_key: \"\"\n    consumer_secret: \"\"\n    access_token: \"\"\n    access_token_secret: \"\"\n    bearer_token: \"\"\n  followed_users:\n    username1:\n      index_minutes: 10  # Override default frequency for this user\n    username2:  # Use default frequency\n  default_index_user_frequency: 60  # Default frequency in minutes\ntasks:\n  index_followed_users:\n    scheduler:\n      type: \"cron\"\n      params:\n        expression: \"*/5 * * * *\"  # Runs every 5 minutes\n    pipeline:\n      - index_tweets\n</code></pre>"},{"location":"agents/twitter_agent/#twitter-credentials","title":"Twitter Credentials","text":"<p>The <code>twitter.credentials</code> section requires valid Twitter API credentials:</p> Field Description <code>username</code> Your Twitter username <code>user_id</code> Your Twitter user ID <code>password</code> Your Twitter password <code>email</code> Email associated with your Twitter account <code>consumer_key</code> API consumer key <code>consumer_secret</code> API consumer secret <code>access_token</code> OAuth access token <code>access_token_secret</code> OAuth access token secret <code>bearer_token</code> Bearer token for API access"},{"location":"agents/twitter_agent/#followed-users-configuration","title":"Followed Users Configuration","text":"<p>The <code>twitter.followed_users</code> section defines which Twitter accounts to monitor:</p> <pre><code>followed_users:\n  elonmusk:  # Twitter handle without the @ symbol\n    index_minutes: 10  # Custom indexing frequency for this user\n  satyanadella:  # Uses the default frequency\n</code></pre> <ul> <li>Each user can have an optional <code>index_minutes</code> setting to override the default frequency</li> <li>Without an <code>index_minutes</code> value, the user will be indexed according to the global <code>default_index_user_frequency</code> setting</li> </ul>"},{"location":"agents/twitter_agent/#global-twitter-settings","title":"Global Twitter Settings","text":"<p>In the <code>twitter</code> section, you can set the following global parameters:</p> Parameter Description Default <code>default_index_user_frequency</code> Default frequency (in minutes) for indexing user tweets 60"},{"location":"agents/twitter_agent/#advanced-global-settings","title":"Advanced Global Settings","text":"<p>Additional Twitter-related settings can be configured when initializing the Pancaik system:</p> <pre><code>import pancaik\n\napp = await pancaik.init({\n    \"db_connection\": \"mongodb://localhost:27017\",\n    \"twitter_concurrency\": 5,  # Maximum concurrent Twitter operations\n    \"twitter_max_concurrent_indexing_users\": 30  # Max users to process in one batch\n})\n</code></pre> Setting Description Default <code>twitter_concurrency</code> Maximum number of concurrent Twitter API calls 5 <code>twitter_max_concurrent_indexing_users</code> Maximum number of users to index in a single batch 30"},{"location":"agents/twitter_agent/#example-configuration","title":"Example Configuration","text":"<pre><code>name: \"Twitter Agent\"\ntwitter:\n  credentials:\n    username: \"my_twitter_username\"\n    user_id: \"12345678\"\n    password: \"my_password\"\n    email: \"email@example.com\"\n    consumer_key: \"abcdefghijklmnopqrstuvwxyz\"\n    consumer_secret: \"123456789abcdefghijklmnopqrstuvwxyz\"\n    access_token: \"123456789-abcdefghijklmnopqrstuvwxyz\"\n    access_token_secret: \"abcdefghijklmnopqrstuvwxyz123456789\"\n    bearer_token: \"AAAAAAAAAAAAAAAAAAAAAA%3DBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB\"\n  followed_users:\n    elonmusk:\n      index_minutes: 10\n    satyanadella:\n    OpenAI:\n  default_index_user_frequency: 60\ntasks:\n  index_followed_users:\n    scheduler:\n      type: \"cron\"\n      params:\n        expression: \"*/5 * * * *\"\n    pipeline:\n      - index_tweets\n</code></pre>"},{"location":"examples/basic_agent/","title":"Basic Agent Example","text":"<p>The Greeter Agent demonstrates the core functionality of Pancaik Agents, showing how to create a simple agent with multiple methods that can be orchestrated using a configuration file.</p>"},{"location":"examples/basic_agent/#agent-implementation","title":"Agent Implementation","text":"<pre><code>import datetime\nfrom pancaik.core.agent import Agent\n\nclass GreetingAgent(Agent):\n    \"\"\"An agent specialized in greetings and conversations\"\"\"\n    name = \"greeting_agent\"\n\n    def __init__(self, id=None, yaml_path=None, use_default_config=True):\n        super().__init__(yaml_path=yaml_path, id=id, use_default_config=use_default_config)\n\n    async def say_current_hour(self):\n        \"\"\"Get and say the current time\"\"\"\n        current_time = datetime.datetime.now()\n        formatted_time = current_time.strftime(\"%H:%M:%S\")\n        time_message = f\"The current time is {formatted_time}.\"\n        print(f\"\ud83d\udd52 {time_message}\")\n        return {\"values\": {\"time\": time_message}}\n\n    async def greet(self, name=\"World\"):\n        \"\"\"Greet a person by name\"\"\"\n        greeting = f\"Hello, {name}! Nice to meet you.\"\n        print(f\"\ud83d\udc4b {greeting}\")\n        return {\"values\": {\"greeting\": greeting, \"tweet\": greeting}}\n\n    async def publish_tweet(self, tweet):\n        \"\"\"Simulate publishing a tweet (just returns the tweet text)\"\"\"\n        print(f\"\ud83d\udc26 Tweet published: {tweet}\")\n        return {\"values\": {\"tweet\": tweet}}\n</code></pre> <p>This simple agent has three main methods:</p> <ol> <li><code>greet</code>: Generates a greeting message for a specified name and prints it with an emoji</li> <li><code>say_current_hour</code>: Returns the current time in a formatted message with a clock emoji</li> <li><code>publish_tweet</code>: Simulates publishing a tweet (demonstration purposes)</li> </ol>"},{"location":"examples/basic_agent/#configuration","title":"Configuration","text":"<p>The agent is configured through a YAML file that defines tasks and their orchestration:</p> <pre><code>tasks:\n  greet_and_tweet:\n    objective: \"Greet a person by name\"\n    pipeline:\n      - greet\n      - publish_tweet\n  greet_share_time:\n    objective: \"Greet a person by name and share the current time\"\n    scheduler:\n      type: \"random_interval\"\n      params:\n        min_minutes: 5\n        max_minutes: 30\n    pipeline:\n      - greet\n      - say_current_hour\n  welcome_sequence:\n    objective: \"Run a full welcome sequence for new users\"\n    pipeline:\n      - greet_and_tweet\n      - say_current_hour\n</code></pre>"},{"location":"examples/basic_agent/#running-the-agent","title":"Running the Agent","text":"<p>There are two ways to run the agent:</p>"},{"location":"examples/basic_agent/#1-direct-script-execution","title":"1. Direct Script Execution","text":"<pre><code>import asyncio\nfrom pathlib import Path\nimport sys\n\n# Add src directory to path\nsrc_path = str(Path(__file__).parent.parent.parent / \"src\")\nif src_path not in sys.path:\n    sys.path.insert(0, src_path)\n\nfrom greeter_agent import GreetingAgent\n\nasync def main():\n    # Create agent\n    greeter = GreetingAgent(id=\"demo_greeter\")\n\n    # Run various greeting tasks\n    await greeter.run(\"greet\", name=\"Alice\")\n    await greeter.run(\"greet_share_time\", name=\"Bob\")\n    await greeter.run(\"publish_tweet\", tweet=\"Having a great time with Pancaik! \ud83e\udd5e\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"examples/basic_agent/#2-fastapi-server-integration","title":"2. FastAPI Server Integration","text":"<p>You can also run the agent as part of a FastAPI server, which allows for HTTP-based interaction and scheduled task execution:</p> <pre><code>from fastapi import FastAPI, APIRouter\nfrom datetime import datetime, timedelta\nfrom pancaik import init\nfrom pancaik.core import TaskHandler\nfrom pancaik.core.config import get_config\n\napp = FastAPI()\nrouter = APIRouter()\n\n@router.get(\"/greet/{name}\")\nasync def greet_person(name: str):\n    greeter = GreetingAgent()\n    task_id = await greeter.schedule_task(\n        task_name=\"greet_share_time\", \n        next_run=datetime.now(), \n        params={\"name\": name}\n    )\n    return {\"task_id\": task_id, \"message\": f\"Scheduled greeting for {name}\"}\n\n# Initialize Pancaik with configuration\nawait init({\n    \"db_connection\": \"mongodb://localhost:27017/pancaik\",\n    \"run_continuous\": True,\n    \"app_title\": \"Greeter Agent Demo\",\n    \"sleep_interval\": 5,\n    \"task_limit\": 10\n})\n</code></pre>"},{"location":"examples/basic_agent/#key-features-demonstrated","title":"Key Features Demonstrated","text":"<p>This example demonstrates several key features of Pancaik Agents:</p> <ol> <li>Task Definition: Define tasks in YAML configuration</li> <li>Method Orchestration: Chain methods together in pipelines</li> <li>Scheduled Execution: Schedule tasks with specific run times or intervals</li> <li>Return Values: Return structured data with the <code>values</code> key</li> <li>Task Composition: Combine tasks to create more complex workflows</li> <li>HTTP Integration: Expose agent functionality via FastAPI endpoints</li> <li>Visual Feedback: Use emojis and print statements for better visibility</li> <li>Database Integration: MongoDB support for task persistence</li> </ol> <p>The Greeter Agent serves as a great starting point for understanding the fundamental concepts of Pancaik Agents before moving on to more complex integrations. </p>"},{"location":"examples/crewai_integration/","title":"CrewAI Integration","text":"<p>Pancaik Agents offers seamless integration with CrewAI, a framework for orchestrating role-playing AI agents. This integration allows you to create specialized agent teams with different roles working together while maintaining the simplicity and power of Pancaik Agents.</p>"},{"location":"examples/crewai_integration/#example-overview","title":"Example Overview","text":"<p>The CrewAI integration example demonstrates a tweet generation agent that orchestrates a team of specialized agents:</p> <ol> <li>Generator: Creates engaging, concise tweets on various topics</li> <li>Reviewer: Ensures tweets are appropriate, engaging, and error-free</li> <li>Publisher: Makes final decisions on tweet publication</li> </ol> <p>This example showcases how Pancaik Agents can leverage CrewAI's role-based agent design while maintaining a clean, consistent interface.</p>"},{"location":"examples/crewai_integration/#implementation","title":"Implementation","text":"<pre><code>from typing import Dict, List, Any\nimport random\n\n# Pancaik imports\nfrom pancaik.core.agent import Agent\n\n# LangChain imports\nfrom langchain_openai import ChatOpenAI\n\n# CrewAI imports\nfrom crewai import Crew, Task, Agent as CrewAgent\n\nclass TweetAgent(Agent):\n    \"\"\"An agent specialized in generating and publishing tweets using CrewAI\"\"\"\n    name = \"tweet_agent\"\n\n    # Default topics for tweets\n    TOPICS = [\"AI\", \"Coding\", \"Tech\", \"Data\", \"Python\", \"Open source\"]\n\n    def __init__(self, api_key=None, id=None, yaml_path=None, topics=None):\n        \"\"\"Initialize the Tweet Agent\"\"\"\n        super().__init__(yaml_path=yaml_path, id=id)\n        self.api_key = api_key\n        self.llm = ChatOpenAI(api_key=api_key)\n        self.topics = topics or self.TOPICS\n        self.crew = self._create_crew()\n</code></pre>"},{"location":"examples/crewai_integration/#creating-the-crew","title":"Creating the Crew","text":"<p>The core of the CrewAI integration is the creation of a crew with specialized agents and tasks:</p> <pre><code>def _create_crew(self):\n    \"\"\"Create the tweet generation workflow as a CrewAI Crew\"\"\"\n    # Define CrewAI agents for each role\n    generator = CrewAgent(\n        role=\"Tweet Generator\",\n        goal=\"Create engaging, concise tweets on various topics\",\n        backstory=\"You are a social media expert who can create engaging tweets that resonate with audiences.\",\n        verbose=True,\n        llm=self.llm\n    )\n\n    reviewer = CrewAgent(\n        role=\"Tweet Reviewer\",\n        goal=\"Ensure tweets are engaging, appropriate, and error-free\",\n        backstory=\"You have a keen eye for quality and can spot issues in content before publication.\",\n        verbose=True,\n        llm=self.llm\n    )\n\n    publisher = CrewAgent(\n        role=\"Tweet Publisher\",\n        goal=\"Make final decisions on tweet publication\",\n        backstory=\"You understand what makes content go viral and make the final call on publishing.\",\n        verbose=True,\n        llm=self.llm\n    )\n\n    # Create tasks for the workflow\n    topic = random.choice(self.TOPICS)\n\n    generate_task = Task(\n        description=f\"Write a short, engaging tweet (max 280 chars) about {topic}. Include a hashtag.\",\n        agent=generator,\n        expected_output=\"A well-crafted tweet ready for review.\"\n    )\n\n    review_task = Task(\n        description=\"Review the tweet for quality, engagement potential, and appropriateness. Suggest revisions if needed.\",\n        agent=reviewer,\n        expected_output=\"Feedback on the tweet with DECISION: REVISE or DECISION: PUBLISH\",\n        context=[generate_task]\n    )\n\n    publish_task = Task(\n        description=\"Publish the approved tweet if it meets quality standards.\",\n        agent=publisher,\n        expected_output=\"The final published tweet.\",\n        context=[review_task]\n    )\n\n    # Create and return the crew\n    crew = Crew(\n        agents=[generator, reviewer, publisher],\n        tasks=[generate_task, review_task, publish_task],\n        verbose=True\n    )\n\n    return crew\n</code></pre>"},{"location":"examples/crewai_integration/#running-the-workflow","title":"Running the Workflow","text":"<pre><code>async def run_tweet_cycle(self):\n    \"\"\"Run a complete tweet generation cycle\"\"\"\n    # Re-initialize crew with new random topic each time\n    self.crew = self._create_crew()\n\n    # Execute the crew workflow\n    result = self.crew.kickoff()\n\n    # Extract the tweet from the result\n    tweet = str(result)\n\n    # Twitter character limit enforcement\n    if len(tweet) &gt; 280:\n        tweet = tweet[:277] + \"...\"\n\n    print(f\"\\nTWEET PUBLISHED: {tweet}\\n\")\n\n    return {\n        \"tweet\": tweet\n    }\n</code></pre>"},{"location":"examples/crewai_integration/#configuration","title":"Configuration","text":"<p>The agent can be configured with a simple YAML file:</p> <pre><code>name: tweet_agent\ndescription: \"Tweet generation agent using CrewAI\"\nopenai_api_key: ${OPENAI_API_KEY}\n\ndefault_topics:\n  - Technology\n  - AI\n  - Programming\n  - Data Science\n  - Cloud Computing\n</code></pre>"},{"location":"examples/crewai_integration/#running-the-agent","title":"Running the Agent","text":"<pre><code>from crewai_agent import TweetAgent\nimport os\n\nasync def main():\n    # Initialize the agent\n    api_key = os.environ.get(\"OPENAI_API_KEY\")\n    agent = TweetAgent(api_key=api_key, yaml_path=\"config.yaml\")\n\n    # Run the tweet generation workflow\n    result = await agent.run_tweet_cycle()\n\n    print(f\"Published tweet: {result['tweet']}\")\n\nif __name__ == \"__main__\":\n    import asyncio\n    asyncio.run(main())\n</code></pre>"},{"location":"examples/crewai_integration/#key-features-demonstrated","title":"Key Features Demonstrated","text":"<p>This example shows several powerful features of integrating CrewAI with Pancaik Agents:</p> <ol> <li>Role-Based Agents: Create specialized agents with specific goals and backstories</li> <li>Task Definition: Define tasks with clear descriptions and expected outputs</li> <li>Agent Collaboration: Allow agents to work together, building on each others' outputs</li> <li>Sequential Workflows: Create logical sequences of tasks that pass context between steps</li> <li>Integration Simplicity: Seamlessly integrate CrewAI while maintaining the Pancaik Agent interface</li> </ol>"},{"location":"examples/crewai_integration/#dependencies","title":"Dependencies","text":"<p>To run this example, you'll need to install the following packages:</p> <pre><code>crewai\nlangchain-openai\n</code></pre>"},{"location":"examples/crewai_integration/#why-use-crewai-integration","title":"Why Use CrewAI Integration?","text":"<p>The CrewAI integration is particularly useful when:</p> <ol> <li>You need multiple specialized agents to solve different aspects of a problem</li> <li>Role-playing and agent personalities are important to your application</li> <li>You want to create a team of agents with clear responsibilities</li> <li>You need to orchestrate complex multi-agent workflows</li> </ol> <p>This integration demonstrates how Pancaik Agents can leverage the role-based design of CrewAI while maintaining a clean, consistent interface\u2014allowing you to create powerful multi-agent systems with minimal complexity. </p>"},{"location":"examples/langgraph_integration/","title":"LangGraph Integration","text":"<p>Pancaik Agents provides seamless integration with LangGraph, a library for building stateful, multi-actor applications with LLMs. This integration allows you to create complex, multi-step workflows with conditional logic while keeping the simplicity and power of Pancaik Agents.</p>"},{"location":"examples/langgraph_integration/#example-overview","title":"Example Overview","text":"<p>The LangGraph integration example demonstrates a tweet generation agent with a three-step workflow:</p> <ol> <li>Generate: Create a tweet about a random topic</li> <li>Review: Evaluate the tweet for quality and appropriateness</li> <li>Publish: Publish the approved tweet or loop back for revision</li> </ol> <p>The power of LangGraph lies in its ability to define complex workflows with conditional logic\u2014in this case, the decision to either publish a tweet or revise it based on quality review.</p>"},{"location":"examples/langgraph_integration/#implementation","title":"Implementation","text":"<pre><code>from typing import Annotated, List, Dict, Any\nimport random\n\n# Pancaik imports\nfrom pancaik.core.agent import Agent\n\n# LangChain imports\nfrom langchain_openai import ChatOpenAI\n\n# LangGraph imports\nfrom langgraph.graph import StateGraph\nfrom langgraph.graph.message import add_messages\nfrom typing_extensions import TypedDict\n\n# Define the state structure for our LangGraph\nclass State(TypedDict):\n    \"\"\"State maintained throughout the LangGraph workflow\"\"\"\n    messages: Annotated[list, add_messages]  # Conversation history\n    tweets: List[str]  # List of generated tweets\n\nclass TweetAgent(Agent):\n    \"\"\"An agent specialized in generating and publishing tweets using LangGraph\"\"\"\n    name = \"tweet_agent\"\n\n    # Default topics for tweets\n    TOPICS = [\"AI\", \"Coding\", \"Tech\", \"Data\", \"Python\", \"Open source\"]\n\n    def __init__(self, api_key=None, id=None, yaml_path=None, topics=None):\n        super().__init__(yaml_path=yaml_path, id=id)\n        self.llm = ChatOpenAI(api_key=api_key)\n        self.topics = topics or self.TOPICS\n        # Build graph during initialization\n        self.graph = self._create_workflow()\n\n    def _create_workflow(self):\n        \"\"\"Create the tweet generation workflow as a LangGraph\"\"\"\n        workflow = StateGraph(State)\n\n        # Add nodes for each step in our workflow\n        workflow.add_node(\"generate\", self._generate_tweet)\n        workflow.add_node(\"review\", self._review_tweet)\n        workflow.add_node(\"publish\", self._publish_tweet)\n\n        # Connect workflow nodes with conditional logic\n        workflow.set_entry_point(\"generate\")\n        workflow.add_edge(\"generate\", \"review\")\n\n        # Add conditional logic - if review says \"REVISE\", go back to generate\n        workflow.add_conditional_edges(\n            \"review\",\n            lambda state: \"DECISION: REVISE\" in self._get_last_message_content(state),\n            {True: \"generate\", False: \"publish\"}\n        )\n\n        workflow.set_finish_point(\"publish\")\n\n        return workflow.compile()\n</code></pre>"},{"location":"examples/langgraph_integration/#workflow-methods","title":"Workflow Methods","text":"<p>Each step in the workflow is implemented as a method that processes the state and returns an updated state:</p> <pre><code>def _generate_tweet(self, state: State) -&gt; Dict:\n    \"\"\"Generate a tweet about a random topic\"\"\"\n    # Select random topic\n    topic = random.choice(self.topics)\n\n    # Initial prompt or use existing messages for revision\n    if not state.get(\"messages\") or len(state[\"messages\"]) == 0:\n        # First time generating a tweet\n        prompt = f\"Write a short, engaging tweet (max 280 chars) about {topic}. Include a hashtag.\"\n        messages = [{\"role\": \"user\", \"content\": prompt}]\n    else:\n        # Revision based on previous feedback\n        messages = state[\"messages\"]\n\n    # Generate the tweet using LLM\n    response = self.llm.invoke(messages)\n    tweet_text = response.content.strip()\n\n    # Twitter character limit enforcement\n    if len(tweet_text) &gt; 280:\n        tweet_text = tweet_text[:277] + \"...\"\n\n    # Ensure tweets list exists\n    existing_tweets = state.get(\"tweets\", [])\n\n    return {\n        \"messages\": messages + [response],\n        \"tweets\": existing_tweets + [tweet_text]\n    }\n\ndef _review_tweet(self, state: State) -&gt; Dict:\n    \"\"\"Review the generated tweet for quality and appropriateness\"\"\"\n    # Get the current tweet for review\n    current_tweet = state[\"tweets\"][-1]\n\n    # Review criteria prompt\n    review_prompt = f\"\"\"Review this tweet: \"{current_tweet}\"\n    Is it engaging and appropriate?\n    End with DECISION: REVISE or DECISION: PUBLISH\"\"\"\n\n    review_response = self.llm.invoke([{\"role\": \"user\", \"content\": review_prompt}])\n\n    # Update state with review feedback\n    return {\n        \"messages\": state[\"messages\"] + [review_response],\n        \"tweets\": state[\"tweets\"]\n    }\n\ndef _publish_tweet(self, state: State) -&gt; Dict:\n    \"\"\"Publish the approved tweet\"\"\"\n    final_tweet = state[\"tweets\"][-1]\n    print(f\"\\nTWEET PUBLISHED: {final_tweet}\\n\")\n\n    # Return final state\n    return {\"messages\": [], \"tweets\": state[\"tweets\"]}\n\nasync def run_tweet_cycle(self):\n    \"\"\"Run a complete tweet generation cycle\"\"\"\n    result = self.graph.invoke({\"messages\": [], \"tweets\": []})\n    return {\n        \"tweet\": result[\"tweets\"][0] if result.get(\"tweets\") and result[\"tweets\"] else None\n    }\n</code></pre>"},{"location":"examples/langgraph_integration/#configuration","title":"Configuration","text":"<p>The agent can be configured with a simple YAML file:</p> <pre><code>name: tweet_agent\ndescription: \"Tweet generation agent using LangGraph\"\nopenai_api_key: ${OPENAI_API_KEY}\n\ndefault_topics:\n  - Technology\n  - AI\n  - Programming\n  - Data Science\n  - Cloud Computing\n</code></pre>"},{"location":"examples/langgraph_integration/#running-the-agent","title":"Running the Agent","text":"<pre><code>from langgraph_agent import TweetAgent\nimport os\n\nasync def main():\n    # Initialize the agent\n    api_key = os.environ.get(\"OPENAI_API_KEY\")\n    agent = TweetAgent(api_key=api_key, yaml_path=\"config.yaml\")\n\n    # Run the tweet generation workflow\n    result = await agent.run_tweet_cycle()\n\n    print(f\"Published tweet: {result['tweet']}\")\n\nif __name__ == \"__main__\":\n    import asyncio\n    asyncio.run(main())\n</code></pre>"},{"location":"examples/langgraph_integration/#key-features-demonstrated","title":"Key Features Demonstrated","text":"<p>This example shows several powerful features of integrating LangGraph with Pancaik Agents:</p> <ol> <li>Stateful Workflows: Maintain state across multiple steps of a workflow</li> <li>Conditional Logic: Create branching logic based on LLM decisions</li> <li>Feedback Loops: Implement revision cycles for content refinement</li> <li>Workflow Definition: Define complex workflows with clear separation of concerns</li> <li>Integration Simplicity: Seamlessly integrate LangGraph while maintaining the Pancaik Agent interface</li> </ol>"},{"location":"examples/langgraph_integration/#dependencies","title":"Dependencies","text":"<p>To run this example, you'll need to install the following packages:</p> <pre><code>langchain\nlanggraph\nlangchain-openai\n</code></pre> <p>This integration demonstrates how Pancaik Agents can leverage the powerful workflow capabilities of LangGraph while maintaining its clean, simple interface\u2014giving you the best of both worlds. </p>"},{"location":"middleware/","title":"Middleware Overview","text":"<p>Pancaik integrates with various middleware services to extend its capabilities and provide additional functionality. These integrations enable agents to interact with external services seamlessly while abstracting away complex implementation details.</p>"},{"location":"middleware/#available-middleware","title":"Available Middleware","text":""},{"location":"middleware/#x-non-api-service","title":"X-Non-API Service","text":"<p>A RESTful API wrapper for Twitter/X platform that enables interaction without requiring official API access. This service is particularly useful for:</p> <ul> <li>Automated social media management</li> <li>Twitter data collection and analysis</li> <li>Social media monitoring</li> <li>Engagement automation</li> </ul> <p>See the X-Non-API Service documentation for detailed setup and usage instructions.</p>"},{"location":"middleware/#coming-soon","title":"Coming Soon","text":"<p>We are actively working on integrating more middleware services to expand Pancaik's capabilities:</p>"},{"location":"middleware/#telegram-integration","title":"Telegram Integration","text":"<p>A middleware service that enables seamless interaction with the Telegram messaging platform. Key features will include:</p> <ul> <li>Bot creation and management</li> <li>Message sending and receiving</li> <li>Group chat interactions</li> <li>Media file handling</li> <li>Interactive keyboard support</li> </ul>"},{"location":"middleware/#discord-integration","title":"Discord Integration","text":"<p>A comprehensive Discord bot and API integration service that will provide:</p> <ul> <li>Server management capabilities</li> <li>Channel interactions</li> <li>Role management</li> <li>Voice channel support</li> <li>Message and event handling</li> </ul>"},{"location":"middleware/#pipedrive-crm","title":"Pipedrive CRM","text":"<p>Integration with Pipedrive CRM platform for advanced sales and customer relationship management:</p> <ul> <li>Deal management</li> <li>Contact and organization handling</li> <li>Activity tracking</li> <li>Custom fields and workflows</li> <li>Sales pipeline automation</li> </ul>"},{"location":"middleware/#retell-voice-ai","title":"Retell Voice AI","text":"<p>Advanced voice AI integration powered by Retell for natural conversations:</p> <ul> <li>Real-time voice synthesis</li> <li>Natural language processing</li> <li>Voice cloning capabilities</li> <li>Multi-language support</li> <li>Custom voice personality creation</li> </ul> <p>Additional planned integrations include: - WhatsApp Business API - LinkedIn API - Slack Integration - Microsoft Teams</p> <p>Stay tuned for updates! </p>"},{"location":"middleware/x-non-api/","title":"X-Non-API Service","text":"<p>\u26a0\ufe0f IMPORTANT USAGE ADVISORY</p> <p>This service is intended for testing and development purposes only. For production deployments: - Use the official Twitter/X API through their developer platform - Obtain proper API credentials and comply with rate limits - Follow Twitter's Developer Terms of Service</p> <p>Using this service in production may: - Violate Twitter/X's Terms of Service - Result in account suspension - Have legal implications - Be subject to unexpected changes in Twitter/X's systems</p>"},{"location":"middleware/x-non-api/#legal-disclaimer","title":"Legal Disclaimer","text":"<ol> <li> <p>Terms of Service Compliance: Users are solely responsible for ensuring their usage complies with Twitter/X's Terms of Service and Developer Agreement.</p> </li> <li> <p>No Warranty: This service is provided \"AS IS\" without any warranty of any kind. The developers make no guarantees about its functionality, reliability, or continued availability.</p> </li> <li> <p>Production Usage: For production applications, users MUST use Twitter's official API services. This service is NOT a replacement for official API access.</p> </li> <li> <p>Risk Assumption: By using this service, you assume all risks associated with its use, including the risk of account suspension, service interruption, or other consequences.</p> </li> <li> <p>Liability: The developers and contributors cannot be held liable for any damages or consequences arising from the use of this service.</p> </li> </ol> <p>The X-Non-API Service is a RESTful API wrapper for the Twitter/X platform that provides a straightforward interface for interacting with Twitter services without requiring official API access. It handles the complexity of Twitter's authentication by persisting cookies in MongoDB, enabling reliable session management across multiple containers.</p>"},{"location":"middleware/x-non-api/#features","title":"Features","text":"<ul> <li>Login and profile information retrieval</li> <li>Timeline access (user and home)</li> <li>Tweet search and posting</li> <li>Interactive API documentation at <code>/docs</code> endpoint</li> <li>Cookie-based session management with MongoDB</li> <li>No Twitter API tokens required</li> </ul>"},{"location":"middleware/x-non-api/#setup-instructions","title":"Setup Instructions","text":""},{"location":"middleware/x-non-api/#mac-users-recommended","title":"Mac Users (Recommended)","text":"<p>For Mac users, running the service locally is recommended due to potential Docker networking issues:</p> <pre><code># Clone the repository\ngit clone https://github.com/jdorado/x-api-service\ncd x-api-service\n\n# Install dependencies\nnpm install\n\n# Install and start MongoDB (if not already installed)\nbrew install mongodb-community\nbrew services start mongodb-community\n\n# Create a .env file\ncat &lt;&lt; EOF &gt; .env\nPORT=6011\nMONGO_CONNECTION=mongodb://localhost:27017/x-api\nEOF\n\n# Start the service\nnpm start\n\n# The API will be available at http://localhost:6011\n</code></pre>"},{"location":"middleware/x-non-api/#docker-setup-linuxwindows-recommended","title":"Docker Setup (Linux/Windows Recommended)","text":"<p>Prerequisites: - Docker and Docker Compose installed</p> <pre><code># Clone the repository\ngit clone https://github.com/jdorado/x-api-service\ncd x-api-service\n\n# Start the services (includes MongoDB)\ndocker-compose up -d\n\n# The API will be available at http://localhost:6011\n</code></pre>"},{"location":"middleware/x-non-api/#configure-pancaik","title":"Configure Pancaik","text":"<p>Add the X-API URL to your Pancaik initialization:</p> <pre><code>app = await init({\n    \"run_continuous\": True,\n    \"app_title\": \"My Twitter Agent\",\n    \"x_api_url\": \"http://localhost:6011/api\"  # Same URL for both local and Docker setups\n})\n</code></pre>"},{"location":"middleware/x-non-api/#usage-in-agents","title":"Usage in Agents","text":""},{"location":"middleware/x-non-api/#basic-tweet-posting","title":"Basic Tweet Posting","text":"<pre><code>from pancaik.utils.x_api import send_tweet\n\nclass TwitterAgent(Agent):\n    async def post_tweet(self, text: str):\n        credentials = {\n            \"username\": \"your_twitter_username\",\n            \"password\": \"your_twitter_password\"\n        }\n        return await send_tweet(text, credentials)\n</code></pre>"},{"location":"middleware/x-non-api/#profile-information","title":"Profile Information","text":"<pre><code>from pancaik.utils.x_api import get_profile\n\nclass TwitterAgent(Agent):\n    async def get_user_info(self, username: str):\n        credentials = {\n            \"username\": \"your_twitter_username\",\n            \"password\": \"your_twitter_password\"\n        }\n        return await get_profile(username, credentials)\n</code></pre>"},{"location":"middleware/x-non-api/#search-tweets","title":"Search Tweets","text":"<pre><code>from pancaik.utils.x_api import search\n\nclass TwitterAgent(Agent):\n    async def search_tweets(self, query: str):\n        credentials = {\n            \"username\": \"your_twitter_username\",\n            \"password\": \"your_twitter_password\"\n        }\n        return await search(query, credentials)\n</code></pre>"},{"location":"middleware/x-non-api/#api-documentation","title":"API Documentation","text":"<p>Once the service is running, you can access the interactive API documentation at:</p> <ul> <li>Local: http://localhost:6011/docs</li> <li>Docker: http://localhost:6011/docs</li> </ul> <p>The Swagger UI provides: - Complete documentation of all endpoints - Request/response schemas - Interactive testing interface</p>"},{"location":"middleware/x-non-api/#security-considerations","title":"Security Considerations","text":"<ul> <li>Store credentials securely using environment variables or a secure configuration management system</li> <li>Use HTTPS in production environments</li> <li>Implement rate limiting for production deployments</li> <li>Monitor for suspicious activity</li> </ul>"},{"location":"middleware/x-non-api/#troubleshooting","title":"Troubleshooting","text":""},{"location":"middleware/x-non-api/#platform-specific-issues","title":"Platform-Specific Issues","text":"<ol> <li>Mac-Specific Issues</li> <li>Docker networking problems are common on Mac:      <pre><code># If using Docker and seeing connection issues, switch to local setup:\nbrew services stop mongodb-community  # Stop any existing MongoDB\nbrew services start mongodb-community # Ensure fresh MongoDB start\nnpm start  # Run service locally\n</code></pre></li> <li>Local MongoDB connection issues:      <pre><code># Verify MongoDB is running\nbrew services list | grep mongodb\n# Check MongoDB logs\ntail -f /usr/local/var/log/mongodb/mongo.log\n</code></pre></li> <li>Port conflicts:      <pre><code># Check if port 6011 is in use\nlsof -i :6011\n# If needed, change port in .env file\necho \"PORT=6012\" &gt;&gt; .env\n</code></pre></li> </ol>"},{"location":"middleware/x-non-api/#first-time-setup-issues","title":"First-Time Setup Issues","text":"<p>The most common issue is the initial authentication setup. Follow these steps for first-time setup:</p> <ol> <li>Mobile Device Login (Recommended Method) <pre><code># First, start the X-API service\ndocker-compose up -d\n</code></pre>    Then:</li> <li>Open X (Twitter) on your mobile device</li> <li>Ensure your mobile device is on the same network as the X-API service</li> <li>Log in to your X account on the mobile device</li> <li>Wait a few minutes for the cookies to be cached</li> <li> <p>Try running your agent script again</p> </li> <li> <p>HTTP 500 Errors    If you're getting 500 Internal Server Error responses:</p> </li> <li>This usually means the authentication cookies are invalid or missing</li> <li>Follow the mobile device login process above</li> <li>Check MongoDB connection and data:    <pre><code># Connect to MongoDB container\ndocker exec -it x-api-mongodb mongosh\n# Check cookies collection\nuse x-api\ndb.cookies.find()\n</code></pre></li> </ol>"},{"location":"middleware/x-non-api/#common-runtime-issues","title":"Common Runtime Issues","text":"<ol> <li>Connection Problems</li> <li>Verify the X-API service is running:    <pre><code>docker ps | grep x-api\ncurl http://localhost:6011/health\n</code></pre></li> <li>Check MongoDB container status:    <pre><code>docker logs x-api-mongodb\n</code></pre></li> <li> <p>Ensure correct environment variables:    <pre><code># In your .env file\nX_API=\"http://localhost:6011/api\"\n</code></pre></p> </li> <li> <p>Authentication Failures</p> </li> <li>Verify your credentials in the configuration:    <pre><code># twitter_agent.yaml\ntwitter:\n  credentials:\n    username: \"your_username\"\n    password: \"your_password\"\n</code></pre></li> <li>Check for IP restrictions or suspicious activity flags</li> <li>Try refreshing cookies by repeating the mobile login process</li> <li> <p>Ensure you're not using a VPN that might block Twitter</p> </li> <li> <p>Rate Limiting and Performance</p> </li> <li>Implement exponential backoff:    <pre><code>import random\nimport asyncio\n\nasync def with_retry(func, max_retries=3):\n    for attempt in range(max_retries):\n        try:\n            return await func()\n        except Exception as e:\n            if attempt == max_retries - 1:\n                raise\n            wait_time = (2 ** attempt) + random.uniform(0, 1)\n            await asyncio.sleep(wait_time)\n</code></pre></li> <li>Monitor response headers for rate limits</li> <li>Consider using multiple accounts for high-volume operations</li> </ol>"},{"location":"middleware/x-non-api/#verification-steps","title":"Verification Steps","text":"<p>You can verify your setup is working with this simple test:</p> <pre><code>from pancaik.utils.x_api import get_profile\nimport asyncio\n\nasync def verify_setup():\n    credentials = {\n        \"username\": \"your_username\",\n        \"password\": \"your_password\"\n    }\n    profile = await get_profile(credentials[\"username\"], credentials)\n\n    if not profile:\n        print(\"\\nX-API Service Connection Issue:\")\n        print(\"--------------------------------\")\n        print(\"1. Open X (Twitter) on your mobile device\")\n        print(\"2. Ensure device is on the same network\")\n        print(\"3. Log in to your X account\")\n        print(\"4. Try again in a few minutes\")\n        return False\n\n    print(\"\u2713 Setup verified successfully!\")\n    return True\n\n# Run the verification\nasyncio.run(verify_setup())\n</code></pre>"},{"location":"middleware/x-non-api/#best-practices","title":"Best Practices","text":"<ol> <li>Environment Setup</li> <li>Use separate development and production configurations</li> <li>Keep credentials in environment variables</li> <li> <p>Monitor service logs regularly</p> </li> <li> <p>Error Handling</p> </li> <li>Implement proper error handling and retries</li> <li>Log all API interactions for debugging</li> <li> <p>Set up alerts for authentication failures</p> </li> <li> <p>Maintenance</p> </li> <li>Regularly verify cookie validity</li> <li>Update Docker images periodically</li> <li>Monitor MongoDB storage usage</li> </ol>"},{"location":"middleware/x-non-api/#license","title":"License","text":"<p>This middleware is licensed under the MIT License. See the LICENSE file in the repository for details.</p>"},{"location":"middleware/x-non-api/#disclaimer","title":"Disclaimer","text":"<p>This service is not affiliated with, maintained, authorized, endorsed, or sponsored by Twitter, Inc. or any of its affiliates. </p>"},{"location":"services/","title":"Services Overview","text":"<p>Pancaik provides various service components for interacting with external APIs and platforms. These services are designed to be:</p> <ul> <li>Reliable: With fallback mechanisms to ensure operation even during API outages</li> <li>Flexible: Supporting both official API and non-API based interaction methods</li> <li>Well-documented: With comprehensive interfaces and examples</li> <li>Async-first: For optimal performance in modern applications</li> </ul>"},{"location":"services/#available-services","title":"Available Services","text":"<p>Pancaik provides several built-in services that you can use in your agents:</p> <ol> <li>Twitter Service - Interact with Twitter API, post tweets, search tweets, etc.</li> <li>Creating Custom Tools - Learn how to create your own custom tools to extend Pancaik's functionality.</li> </ol> <p>Each service is designed to abstract away the complexities of working with external APIs while providing robust error handling and logging. </p>"},{"location":"services/tools/","title":"Creating Custom Tools","text":"<p>Tools in Pancaik are functions that can be used by agents to perform specific tasks. This guide will walk you through creating your own custom tools that can be integrated with Pancaik agents.</p>"},{"location":"services/tools/#understanding-tools-in-pancaik","title":"Understanding Tools in Pancaik","text":"<p>Tools are asynchronous functions that are registered globally through a decorator, making them accessible to any agent in the system. They follow a consistent pattern:</p> <ol> <li>They are decorated with the <code>@tool</code> decorator</li> <li>They are asynchronous functions (defined with <code>async def</code>)</li> <li>They typically take a <code>data_store</code> parameter for sharing data between tools</li> <li>They return a dictionary with results and optional shared values</li> </ol>"},{"location":"services/tools/#basic-tool-structure","title":"Basic Tool Structure","text":"<p>Here's the basic structure of a Pancaik tool:</p> <pre><code>from typing import Dict, Any\nfrom ...tools.base import tool\n\n@tool\nasync def my_custom_tool(parameter1: str, data_store: Dict[str, Any], optional_param: int = 10):\n    \"\"\"\n    Description of what the tool does.\n\n    Args:\n        parameter1: Description of first parameter\n        data_store: Agent's data store containing configuration and state\n        optional_param: Description of optional parameter with default value\n\n    Returns:\n        Dictionary with operation results\n    \"\"\"\n    # Preconditions\n    assert parameter1, \"parameter1 must be provided\"\n\n    # Your tool logic goes here\n    result = f\"Processed {parameter1} with value {optional_param}\"\n\n    # Return dictionary with results and values to share\n    return {\n        \"status\": \"success\",\n        \"result\": result,\n        \"values\": {\n            # Values to share in the data_store\n            \"processed_value\": result\n        }\n    }\n</code></pre>"},{"location":"services/tools/#sharing-data-between-tools","title":"Sharing Data Between Tools","text":"<p>The <code>data_store</code> parameter is a dictionary that is passed between tools in a pipeline. To share data with other tools:</p> <ol> <li>Include a <code>values</code> key in your return dictionary</li> <li>Add key-value pairs in the <code>values</code> dictionary that should be shared</li> <li>These values will be automatically added to the agent's <code>data_store</code></li> </ol> <p>Example:</p> <pre><code>return {\n    \"status\": \"success\",\n    \"result\": \"Operation completed\",\n    \"values\": {\n        \"important_data\": processed_data,\n        \"operation_id\": generated_id\n    }\n}\n</code></pre>"},{"location":"services/tools/#tool-organization","title":"Tool Organization","text":"<p>Tools are typically organized by service or functionality. For example:</p> <ul> <li>Twitter-related tools are in <code>src/pancaik/services/twitter/tools.py</code></li> <li>Database-related tools might be in <code>src/pancaik/services/database/tools.py</code></li> </ul>"},{"location":"services/tools/#best-practices-for-tool-development","title":"Best Practices for Tool Development","text":""},{"location":"services/tools/#1-follow-design-by-contract-principles","title":"1. Follow Design by Contract Principles","text":"<p>Always add assertions to validate: - Preconditions: What must be true before the function executes - Postconditions: What must be true after the function executes - Invariants: What must remain true throughout the function execution</p> <pre><code>@tool\nasync def example_tool(parameter: str, data_store: Dict[str, Any]):\n    # Preconditions\n    assert parameter, \"Parameter must be provided\"\n    assert \"config\" in data_store, \"Config must be in the data store\"\n\n    # Function logic\n    result = process_data(parameter)\n\n    # Postconditions\n    assert result is not None, \"Result must not be None\"\n\n    return {\"status\": \"success\", \"result\": result}\n</code></pre>"},{"location":"services/tools/#2-provide-comprehensive-documentation","title":"2. Provide Comprehensive Documentation","text":"<p>Always include detailed docstrings that explain: - What the tool does - Parameters with descriptions - Return value structure - Any side effects</p>"},{"location":"services/tools/#3-handle-errors-gracefully","title":"3. Handle Errors Gracefully","text":"<p>Use try/except blocks to catch and handle errors:</p> <pre><code>@tool\nasync def safe_tool(parameter: str, data_store: Dict[str, Any]):\n    try:\n        # Tool logic\n        result = process_data(parameter)\n        return {\n            \"status\": \"success\",\n            \"result\": result\n        }\n    except Exception as e:\n        logger.error(f\"Error in safe_tool: {str(e)}\")\n        return {\n            \"status\": \"error\",\n            \"error\": str(e)\n        }\n</code></pre>"},{"location":"services/tools/#4-use-logging","title":"4. Use Logging","text":"<p>Import and use the logger from config:</p> <pre><code>from ...core.config import logger\n\n@tool\nasync def logging_tool(parameter: str, data_store: Dict[str, Any]):\n    logger.info(f\"Starting processing of {parameter}\")\n    # Tool logic\n    logger.debug(\"Processing complete\")\n    return {\"status\": \"success\"}\n</code></pre>"},{"location":"services/tools/#real-world-example-twitter-tool","title":"Real-World Example: Twitter Tool","text":"<p>Here's a simplified version of the <code>index_user_tweets</code> tool from the Twitter service:</p> <pre><code>@tool\nasync def index_user_tweets(twitter_handle: str, data_store: Dict[str, Any], max_tweets: int = 100):\n    \"\"\"\n    Indexes tweets from a specific user for searching later.\n\n    Args:\n        twitter_handle: Twitter handle/username to index\n        data_store: Agent's data store containing configuration and state\n        max_tweets: Maximum number of tweets to fetch (default: 100)\n\n    Returns:\n        Dictionary with indexing operation results\n    \"\"\"\n    # Preconditions\n    assert twitter_handle, \"Twitter handle must be provided\"\n    assert max_tweets &gt; 0, \"max_tweets must be positive\"\n\n    # Extract credentials from data_store\n    credentials = data_store.get(\"config\", {}).get(\"twitter\", {}).get(\"credentials\", {})\n    assert credentials, \"Twitter credentials must be in the agent's data store\"\n\n    try:\n        # Fetch and index tweets\n        handler = TwitterHandler()\n        tweets = await client.get_latest_tweets(credentials, twitter_handle, max_tweets=max_tweets)\n\n        if tweets:\n            # Store tweets in database\n            await handler.insert_tweets(tweets)\n\n            result = {\n                \"status\": \"success\",\n                \"indexed_count\": len(tweets),\n                \"values\": {\n                    \"twitter_handle\": twitter_handle,\n                    \"indexed_tweets_count\": len(tweets)\n                }\n            }\n        else:\n            result = {\n                \"status\": \"no_tweets_found\",\n                \"indexed_count\": 0\n            }\n\n        return result\n\n    except Exception as e:\n        logger.error(f\"Error indexing tweets: {str(e)}\")\n        return {\n            \"status\": \"error\",\n            \"error\": str(e),\n            \"indexed_count\": 0\n        }\n</code></pre>"},{"location":"services/tools/#integrating-tools-with-agents","title":"Integrating Tools with Agents","text":"<p>Once you've created a tool, you can use it in agent task pipelines:</p> <pre><code>tasks:\n  analyze_twitter_user:\n    description: \"Analyze a Twitter user's recent tweets\"\n    pipeline:\n      - index_user_tweets\n      - analyze_sentiment\n      - generate_report\n</code></pre> <p>The agent will execute the tools in the order specified in the pipeline, with each tool's shared values being passed to the next tool via the data_store.</p>"},{"location":"services/tools/#testing-your-tools","title":"Testing Your Tools","text":"<p>It's recommended to write tests for your tools to ensure they work as expected:</p> <pre><code>import pytest\n\n@pytest.mark.asyncio\nasync def test_my_custom_tool():\n    # Setup\n    data_store = {\"config\": {...}}\n\n    # Execute\n    result = await my_custom_tool(\"test_param\", data_store)\n\n    # Assert\n    assert result[\"status\"] == \"success\"\n    assert \"processed_value\" in result[\"values\"]\n</code></pre>"},{"location":"services/tools/#conclusion","title":"Conclusion","text":"<p>By following these guidelines, you can create powerful, reusable tools that integrate seamlessly with Pancaik agents. Remember to:</p> <ol> <li>Use the <code>@tool</code> decorator</li> <li>Make functions asynchronous</li> <li>Include <code>data_store</code> parameter</li> <li>Follow design by contract principles</li> <li>Return a dictionary with results and shared values</li> <li>Organize tools by service or functionality</li> <li>Write comprehensive documentation and tests </li> </ol>"},{"location":"services/twitter/","title":"Twitter Service","text":"<p>A comprehensive service for interacting with Twitter/X through both official API and non-API methods. This service provides dual-strategy access to ensure reliable operation and handle API rate limits gracefully.</p>"},{"location":"services/twitter/#features","title":"Features","text":"<ul> <li>Tweet operations: create, reply, quote, thread creation</li> <li>Media handling: image upload and attachment</li> <li>Timeline and tweet fetching with fallback strategies</li> <li>Search functionality across both API methods</li> <li>Profile and tweet metadata retrieval</li> <li>Robust error handling and logging</li> <li>Async-first design for optimal performance</li> <li>Non-API access as a fallback strategy</li> </ul>"},{"location":"services/twitter/#configuration","title":"Configuration","text":"<p>The Twitter service requires credentials for authentication. You can provide these in a dictionary format:</p> <pre><code>twitter_config = {\n    # Official API credentials\n    \"consumer_key\": \"YOUR_CONSUMER_KEY\",\n    \"consumer_secret\": \"YOUR_CONSUMER_SECRET\",\n    \"access_token\": \"YOUR_ACCESS_TOKEN\",\n    \"access_token_secret\": \"YOUR_ACCESS_TOKEN_SECRET\",\n    \"bearer_token\": \"YOUR_BEARER_TOKEN\",\n\n    # Non-API credentials (fallback method)\n    \"username\": \"YOUR_USERNAME\",\n    \"password\": \"YOUR_PASSWORD\"  # Optional but recommended for fallback\n}\n</code></pre>"},{"location":"services/twitter/#core-components","title":"Core Components","text":"<p>The Twitter service is structured into several components:</p> <ul> <li>API: Official Twitter API interactions</li> <li>Client: HTTP client and request handling</li> <li>Models: Data models and type definitions</li> <li>Handlers: Database operations and data persistence</li> <li>Tools: Agent-ready functions for AI tools</li> </ul>"},{"location":"services/twitter/#core-functions","title":"Core Functions","text":""},{"location":"services/twitter/#creating-tweets","title":"Creating Tweets","text":"<pre><code>await create_tweet(\n    twitter: Dict,\n    text: str,\n    images: Union[str, List[str]] = None,\n    reply_id: Optional[int] = None,\n    quote_id: Optional[int] = None,\n) -&gt; Optional[Dict]\n</code></pre> <p>Create a tweet with optional media, as a reply, or as a quote tweet.</p>"},{"location":"services/twitter/#parameters","title":"Parameters:","text":"<ul> <li><code>twitter</code>: Dictionary containing credentials</li> <li><code>text</code>: Tweet content text</li> <li><code>images</code>: Optional URL or list of URLs to images to attach</li> <li><code>reply_id</code>: Optional tweet ID to reply to</li> <li><code>quote_id</code>: Optional tweet ID to quote</li> </ul>"},{"location":"services/twitter/#returns","title":"Returns:","text":"<ul> <li>Dictionary containing tweet data or None if unsuccessful</li> </ul>"},{"location":"services/twitter/#creating-tweet-threads","title":"Creating Tweet Threads","text":"<pre><code>async def create_thread(\n    twitter: Dict, \n    texts: List[str], \n    image_urls: Union[str, List[str]] = None\n) -&gt; Optional[int]\n</code></pre> <p>Create a thread of tweets with optional media attachment to the first tweet.</p>"},{"location":"services/twitter/#parameters_1","title":"Parameters:","text":"<ul> <li><code>twitter</code>: Dictionary containing credentials</li> <li><code>texts</code>: List of text content for each tweet in the thread</li> <li><code>image_urls</code>: Optional URL or list of URLs to images to attach to the first tweet</li> </ul>"},{"location":"services/twitter/#returns_1","title":"Returns:","text":"<ul> <li>ID of the first tweet in the thread or None if unsuccessful</li> </ul>"},{"location":"services/twitter/#fetching-tweets","title":"Fetching Tweets","text":"<pre><code>async def get_latest_tweets(\n    twitter: Dict, \n    username: str, \n    user_id: str, \n    max_results: int = 10\n) -&gt; Optional[List[Dict]]\n</code></pre> <p>Fetch the latest tweets for a user, trying non-API methods first.</p>"},{"location":"services/twitter/#parameters_2","title":"Parameters:","text":"<ul> <li><code>twitter</code>: Dictionary containing credentials</li> <li><code>username</code>: Twitter username</li> <li><code>user_id</code>: Twitter user ID</li> <li><code>max_results</code>: Maximum number of tweets to retrieve (default 10)</li> </ul>"},{"location":"services/twitter/#returns_2","title":"Returns:","text":"<ul> <li>List of formatted tweet dictionaries or None if unsuccessful</li> </ul>"},{"location":"services/twitter/#searching-tweets","title":"Searching Tweets","text":"<pre><code>async def search(\n    query: str, \n    twitter: Dict\n) -&gt; Optional[List[Dict]]\n</code></pre> <p>Search tweets based on a query, trying non-API methods as a fallback.</p>"},{"location":"services/twitter/#parameters_3","title":"Parameters:","text":"<ul> <li><code>query</code>: Search query string</li> <li><code>twitter</code>: Dictionary containing credentials</li> </ul>"},{"location":"services/twitter/#returns_3","title":"Returns:","text":"<ul> <li>List of formatted tweet dictionaries or None if unsuccessful</li> </ul>"},{"location":"services/twitter/#getting-a-single-tweet","title":"Getting a Single Tweet","text":"<pre><code>async def get_tweet(\n    tweet_id: str, \n    twitter: Dict\n) -&gt; Optional[Dict]\n</code></pre> <p>Retrieve a single tweet by its ID, trying non-API methods as a fallback.</p>"},{"location":"services/twitter/#parameters_4","title":"Parameters:","text":"<ul> <li><code>tweet_id</code>: ID of the tweet to retrieve</li> <li><code>twitter</code>: Dictionary containing credentials</li> </ul>"},{"location":"services/twitter/#returns_4","title":"Returns:","text":"<ul> <li>Formatted tweet dictionary or None if unsuccessful</li> </ul>"},{"location":"services/twitter/#indexing-user-tweets","title":"Indexing User Tweets","text":"<pre><code>async def index_user_tweets(\n    twitter_handle: str,\n\n    data_store: Dict[str, Any], \n    twitter_user_id: str = None, \n    max_tweets: int = 100\n) -&gt; Dict\n</code></pre> <p>Index a user's tweets into the data store for later use.</p>"},{"location":"services/twitter/#non-api-access-x-non-api","title":"Non-API Access (X-Non-API)","text":"<p>\u26a0\ufe0f IMPORTANT USAGE ADVISORY</p> <p>The non-API access component is intended for testing, development, and fallback purposes only. For primary production deployments: - Use the official Twitter/X API through their developer platform - Obtain proper API credentials and comply with rate limits - Follow Twitter's Developer Terms of Service</p>"},{"location":"services/twitter/#legal-disclaimer","title":"Legal Disclaimer","text":"<ol> <li>Terms of Service Compliance: Users are solely responsible for ensuring their usage complies with Twitter/X's Terms of Service and Developer Agreement.</li> <li>No Warranty: This service is provided \"AS IS\" without any warranty of any kind.</li> <li>Production Usage: For production applications, users SHOULD use Twitter's official API services primarily. The non-API access is a fallback mechanism.</li> <li>Risk Assumption: By using this service, you assume all risks associated with its use, including the risk of account suspension, service interruption, or other consequences.</li> </ol>"},{"location":"services/twitter/#how-non-api-access-works","title":"How Non-API Access Works","text":"<p>The non-API access component works by: 1. Authenticating with Twitter/X using user credentials 2. Managing cookies to maintain session state 3. Making direct HTTP requests to Twitter's web endpoints 4. Parsing responses to extract relevant data</p>"},{"location":"services/twitter/#setup-for-non-api-access","title":"Setup for Non-API Access","text":"<p>To enable non-API access as a fallback, provide both sets of credentials:</p> <pre><code>twitter = {\n    # Primary API credentials\n    \"consumer_key\": \"YOUR_CONSUMER_KEY\",\n    \"consumer_secret\": \"YOUR_CONSUMER_SECRET\",\n    \"access_token\": \"YOUR_ACCESS_TOKEN\",\n    \"access_token_secret\": \"YOUR_ACCESS_TOKEN_SECRET\",\n\n    # Fallback non-API credentials\n    \"username\": \"YOUR_USERNAME\",\n    \"password\": \"YOUR_PASSWORD\"\n}\n</code></pre>"},{"location":"services/twitter/#troubleshooting-non-api-access","title":"Troubleshooting Non-API Access","text":""},{"location":"services/twitter/#authentication-issues","title":"Authentication Issues","text":"<p>If you experience authentication issues with the non-API access:</p> <ol> <li>Reset Cookies: The service automatically persists cookies, but they may need to be refreshed</li> <li>Check Credentials: Verify username and password are correct</li> <li>IP Restrictions: Twitter may limit access based on IP address or unusual activity</li> <li>Rate Limiting: Implement exponential backoff for retries</li> </ol>"},{"location":"services/twitter/#platform-specific-issues","title":"Platform-Specific Issues","text":"<p>For Mac users: <pre><code># If experiencing network issues\nbrew services restart mongodb-community  # If using MongoDB for cookie storage\n</code></pre></p>"},{"location":"services/twitter/#media-handling","title":"Media Handling","text":"<p>The Twitter service provides functions for downloading images and uploading media:</p> <pre><code>async def download_image(url: str) -&gt; Optional[bytes]\nasync def upload_media(twitter: Dict[str, str], data: bytes, filename: str = \"image.jpg\") -&gt; Optional[int]\nasync def process_images(twitter: Dict, urls: Union[str, List[str]]) -&gt; List[int]\n</code></pre>"},{"location":"services/twitter/#error-handling","title":"Error Handling","text":"<p>The service implements robust error handling with detailed logging. All errors are logged with appropriate severity levels, and API rate limiting is gracefully handled with fallback strategies.</p>"},{"location":"services/twitter/#best-practices","title":"Best Practices","text":"<ol> <li>Provide both API and non-API credentials for maximum reliability</li> <li>Handle rate limiting: The service attempts to handle rate limiting automatically but applications should implement appropriate retry logic</li> <li>Monitor logs: The service provides detailed logging that can help identify issues</li> <li>Use async patterns: All methods are async and should be awaited properly</li> <li>Respect Twitter's Terms of Service: Use the non-API access responsibly and only as a fallback</li> </ol>"},{"location":"services/twitter/#example-usage","title":"Example Usage","text":"<pre><code>from pancaik.services.twitter import create_tweet, get_latest_tweets\n\n# Configuration with both API and fallback credentials\ntwitter_config = {\n    \"consumer_key\": \"YOUR_CONSUMER_KEY\",\n    \"consumer_secret\": \"YOUR_CONSUMER_SECRET\",\n    \"access_token\": \"YOUR_ACCESS_TOKEN\",\n    \"access_token_secret\": \"YOUR_ACCESS_TOKEN_SECRET\",\n    \"bearer_token\": \"YOUR_BEARER_TOKEN\",\n    \"username\": \"YOUR_USERNAME\",\n    \"password\": \"YOUR_PASSWORD\"\n}\n\n# Create a tweet\ntweet = await create_tweet(\n    twitter_config,\n    \"Hello world from Pancaik!\",\n    images=[\"https://example.com/image.jpg\"]\n)\n\n# Get latest tweets\ntweets = await get_latest_tweets(\n    twitter_config,\n    \"elonmusk\",\n    \"44196397\"\n)\n</code></pre>"},{"location":"services/twitter/#implementation-notes","title":"Implementation Notes","text":"<p>The service follows Design by Contract principles with appropriate precondition and postcondition checks. All operations include detailed logging to enable effective debugging and monitoring. The implementation is designed to gracefully fall back to non-API methods when official API methods fail or hit rate limits. </p>"}]}